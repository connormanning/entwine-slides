<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Entwine slides</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/entwine.css">
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<script src="js/make-printable.js"></script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">


<!-- 01 - Title slide -->
<section>
    <img src="img/logo/color/entwine_logo_2-color.png" alt="logo"/>
    <h1>500+ Billion Points</h1>
    <h2>Organizing Point Clouds as Infrastructure</h2>
    <h3>Connor Manning</h3>

    <aside class="notes">
        <ul>
            <li>Focus is on the organization aspect: indexing</li>
        </ul>
    </aside>
</section>

<!-- 02 - Problem statement -->
<section>
    <h1>The problem</h1>
    <h2>Can we put Iowa's lidar in a web browser?</h2>
    <p><img src="img/iowa.png" alt="iowa"/></p>

    <aside class="notes">
        <ul>
            <li>Driving force behind implementation</li>
            <li>Why?
                <ul>
                    <li>Well, it would be cool</li>
                    <li>As seen soon, solving this has other benefits</li>
                </ul>
            </li>
        </ul>
    </aside>
</section>

<!-- 03 - Iowa info -->
<section>
    <h1>Iowa lidar collection</h1>

    <ul>
        <li>â‰ˆ 37,000 files</li>
        <li>â‰ˆ 170 billion points</li>
        <li>&gt; 4.5 TB uncompressed</li>
        <li>&gt; 400 GB compressed</li>
    </ul>

    <p><img src="img/iowa-s3-small.png" alt="iowa-s3"/></p>

    <aside class="notes">
        <ul>
            <li>Organized as full-resolution tiles</li>
        </ul>
    </aside>
</section>

<!-- 04 - want a service -->
<section>
    <h1>A point cloud service</h1>
    <ul>
        <li>Client-controlled access
            <ul>
                <li>Hierarchical</li>
                <li>Random-access</li>
                <li>Dynamic resolution</li>
                <li>Flexible</li>
            </ul>
        </li>
        <li>Fragmented dataset â†’ single logical unit</li>
    </ul>

    <aside class="notes">
        <ul>
            <li>Want an abstraction</li>
            <li>Doesn't necessarily need to be a dynamic service</li>
            <li>Static serving isn't ruled out</li>
            <li>Flexible - not <i>only</i> for visualization</li>
        </ul>
    </aside>
</section>

<!-- 05 - why can't we use the data in its current form? -->
<section>
    <h1>Adapting the data as-is?</h1>

    <ul>
        <li>Difficult to access</li>
        <li>Difficult to manage</li>
        <li>Visualization only in pieces</li>
    </ul>

    <figure>
        <img src="img/tiles.png" alt="tiles"/>
        <figcaption><small>Yes, Iowa is flat</small></figcaption>
    </figure>

    <aside class="notes">
        <ul>
            <li>A lot of data here - better not to touch it</li>
            <li>Difficult to access
                <ul>
                    <li>Clients can't drive the access</li>
                    <li>Have an AOI - need large downloads</li>
                    <li>No overview/preview</li>
                </ul>
            </li>
            <li>Difficult to manage - from a <i>logical</i> standpoint
                <ul>
                    <li>Can't treat data as a single unit</li>
                    <li>Need to sidecar metadata?</li>
                </ul>
            </li>
        </ul>
    </aside>
</section>

<!-- 06 - need to reorganize the data -->
<section>
    <h1>Need for reorganization</h1>

    <ul>
        <li>Cannot meet these needs with a <i>meta</i>-index</li>
        <li>Would require too much dynamic work</li>
        <li>Up-front cost is ok to trivialize later work</li>
        <li>TODO Picture?</li>
    </ul>

    <aside class="notes">
        <ul>
            <li>Why no meta-index?
                <ul>
                    <li>Want to treat set as a logical unit</li>
                    <li>Need hierarchical access</li>
                    <li>Low-res overview has minimum of touching each file</li>
                </ul>
            </li>
            <li>Want to make queries trivial
                <ul>
                    <li>Otherwise ms response time impossible</li>
                    <li>Current organization is non-trivial</li>
                </ul>
            </li>
        </ul>
    </aside>
</section>

<!-- 07 - constraints -->
<section>
    <h1>Constraints</h1>

    <ul>
        <li>Memory</li>
        <li class="fragment">Losslessness</li>
        <li class="fragment">Modifiability</li>
        <li class="fragment">Visualization</li>
    </ul>

    <img src="img/free.png" alt="free"/>

    <aside class="notes">
        <ul>
            <li>Memory - can't fit entire uncompressed set in memory</li>
            <li>Lossless - want to cold-store original data</li>
            <li>Modifiability - can add more data after-the-fact</li>
            <li>Visualization
                <ul>
                    <li>millisecond response times</li>
                    <li>LoD structure - targeting dynamic clients</li>
                    <li>Client-controlled - plasio/potree/etc.</li>
                    <li>Static serve preferred - if server required its
                        query implementation should be trivial
                    </li>
                </ul>
            </li>
        </ul>
    </aside>
</section>

<!-- 08 - Assumptions -->
<section>
    <h1>Assumptions</h1>

    <ul>
        <li>Availability of scalable cloud computing</li>
        <li>A parallelizable problem</li>
        <li>Distributed filesystem</li>
    </ul>

    <figure>
        <img src="img/geyser-2.png" alt="geyser"/>
        <h6>Lone Star Geyser</h6>
        <figcaption><small>
            Geysers are kind of like clouds, but cooler.
            Data source: <a href="http://www.erdc.usace.army.mil/Locations/CRREL/Research.aspx">RS/GIS CRREL USACE</a>
        </small></figcaption>
    </figure>

    <aside class="notes">
        <ul>
            <li>Assume we can reasonably rent computing power on-demand</li>
            <li>Parallelizable from <i>practical</i> standpoint
                <ul>
                    <li>Entire dataset not random across all files</li>
                </ul>
            </li>
            <li>Filesystem scales with computing power</li>
        </ul>
    </aside>
</section>

<!-- 09 - Goal: a massive octree -->
<section>
    <h1>Goal: a massive octree</h1>
    <section transition="none">
        <h1>&nbsp;</h1>
        <ul>
            <li>Increase depth â†’ increase resolution</li>
        </ul>

        <figure>
            <img src="img/layers.png" alt="nepal-layers"/>
            <h6>Quadtree depth layering</h6>

            <figcaption><small>
                Data source: Vanuatu village, Nepal.
                <a href="http://www.globaldirt.org">Global DIRT</a>
            </small></figcaption>
        </figure>

        <aside class="notes">
            <ul>
                <li>A natural mechanism for visualization</li>
            </ul>
        </aside>
    </section>
    <section transition="none">
        <h1>&nbsp;</h1>
        <ul>
            <li>Spatially distinct â†’ trivially parallelizable</li>
        </ul>

        <figure>
            <img src="img/quadtree.svg" alt="quadtree-splitting"/>
            <h6>Quadtree splitting</h6>
            <figcaption><small>
                By <a href="//commons.wikimedia.org/wiki/User:David_Eppstein" class="mw-redirect" title="User:David Eppstein">David Eppstein</a>, Public Domain, <a href="https://commons.wikimedia.org/w/index.php?curid=2489019">ðŸ”—</a>
            </small></figcaption>
        </figure>

        <aside class="notes">
            <ul>
                <li>Trivial/natural method of parallelization</li>
            </ul>
        </aside>
    </section>
    <section>
        <h1>&nbsp;</h1>

        <ul>
            <li>Stable &amp; flexible</li>
            <li>Insertion order doesn't matter</li>
            <li>No concept of "balance"</li>
        </ul>

        <figure>
            <img src="img/kd-tree.svg" alt="kd-tree"/>
            <h6>By contrast: a KD-tree - where order matters</h6>
            <figcaption><small>
                By <a href="https://en.wikipedia.org/wiki/User:KiwiSunset" title="en:User:KiwiSunset">KiwiSunset</a> at the <a href="https://en.wikipedia.org/wiki/" title="w:">English language Wikipedia</a>, <a href="http://creativecommons.org/licenses/by-sa/3.0/" title="Creative Commons Attribution-Share Alike 3.0">CC BY-SA 3.0</a>, <a href="https://commons.wikimedia.org/w/index.php?curid=16242249">ðŸ”—</a>
            </small></figcaption>
        </figure>
        <aside class="notes">
            <ul>
                <li>Stable: no matter the impl details, output is the same</li>
                <li>Important for adding new data to index as it's scanned</li>
                <li>Avoids needing heuristics before indexing</li>
            </ul>
        </aside>
    </section>
</section>

<!-- 10 - Intro to octree -->
<section>
    <h1>Octrees</h1>

    <ul>
        <li>The basic implementation is pointer-based</li>
        <li>&gt; 10 TB just for the (64-bit) pointers for Iowa</li>
    </ul>

    <figure>
        <img src="img/octree.png" alt="octree-splitting"/>
        <h6>A classical octree</h6>
        <figcaption><small>
            By <a href="//commons.wikimedia.org/wiki/User:WhiteTimberwolf" title="User:WhiteTimberwolf">WhiteTimberwolf</a>  - <span lang="en">Own work</span>, <a href="http://creativecommons.org/licenses/by-sa/3.0/" title="Creative Commons Attribution-Share Alike 3.0">CC BY-SA 3.0</a>, <a href="https://commons.wikimedia.org/w/index.php?curid=9851485">ðŸ”—</a>
        </small></figcaption>
    </figure>

    <aside class="notes">
        <ul>
            <li>Key point: magnitude of data amplifies algorithmic waste</li>
            <li>Not to mention the lack of caching coherence</li>
            <li>Pointers take up more space then the point data!</li>
            <li>Each node holds a point, or <i>n</i> points</li>
        </ul>
    </aside>
</section>

<!-- 11 - Bucketing overview -->
<section>
    <h1>Buckets of points?</h1>
    <ul>
        <li>Very common</li>
        <li>Minimum addressable node consists of <i>n</i> points</li>
        <li>
            <i>O</i>(<i>depth</i> * <i>bucketSize</i>) if per-point resolution is needed
        </li>
    </ul>

    <figure>
        <span class="line">
            <img src="img/potree-root.png" class="line-4"/>
            <img src="img/potree-child.png" class="line-4"/>
            <img src="img/potree-root-and-child.png" class="line-4"/>
            <img src="img/potree-all-depths.png" class="line-4"/>
        </span>
        <h6>Point bucketing</h6>
        <figcaption><small>
            Source: Potree documentation <a href="https://github.com/potree/potree/blob/master/docs/file_format.md">ðŸ”—</a>
        </small></figcaption>
    </figure>

    <aside class="notes">
        <ul>
            <li>Computational complexity concerns operations which need resolution of a single <i>point</i></li>
            <li>Key operation needing per-point resolution: spacing</li>
            <li>Problem: scalability to massive datasets</li>
        </ul>
    </aside>
</section>

<!-- 12 - Bucketing computational complexity -->
<section>
    <h1>Bucket example</h1>
    <ul>
        <li>Strict spacing for Iowa data
            <span class="fragment">
                <ul>
                    <li><i>Average depth</i> = 10</li>
                    <li><i>Bucket size</i> = 65,536</li>
                </ul>
            </span>
        </li>
        <li class="fragment">Average comparisons per point: 655,360</li>
        <li class="fragment">
            &gt; 10<sup><small>17</small></sup> comparisons for IA
        </li>
    </ul>

    <aside class="notes">
        <ul>
            <li>Strict spacing requires <i>per-point</i> resolution</li>
            <li>Average comparisons is <i>worst-case</i>!</li>
        </ul>
    </aside>
</section>

<!-- 13 - Decimation issues -->
<section>
    <h1>Discrete split step?</h1>
    <ul>
        <li>Split bucketed node when <i>numPoints > bucketSize</i></li>
        <li>Decimation step reduces concurrent throughput</li>
        <li>Will happen to high-traffic nodes frequently</li>
    </ul>

    <figure class="fragment">
        <span class="line">
            <img src="img/side-by-side-no-swap.png" alt="one" class="side-by-side"/>
            <img src="img/side-by-side-swapped.png" alt="two" class="side-by-side"/>
        </span>
            <h6>Lack of spacing guarantee - effect on visualization</h6>
        <figcaption><small>
        </small></figcaption>
    </figure>

    <aside class="notes">
        <ul>
            <li><i>n</i> is numPoints, <i>B</i> is bucket size</li>
            <li>
                Doing spacing analysis here would be <i>O(n<sup>2</sup>)</i>
            </li>
            <li>
                Lack of high-resolution inspection â†’ insertion order matters!
            </li>
        </ul>
    </aside>
</section>

<!-- 14 - Entwine's linearization -->
<section>
    <h1>Linearizing the tree</h1>
    <section>
        <h1>&nbsp</h1>

        <ul>
            <li>For a single depth: Z-order curve</li>
            <li>Entirely positionally based - zero theoretical waste</li>
        </ul>

        <figure>
            <img src="img/morton-ordering.png" alt="morton-ordering"/>
            <h6>Z-order curve for depth 3</h6>
            <figcaption><small>
                By user <a href="http://www.slideserve.com/jace">Jace</a>,
                <a href="http://www.slideserve.com/jace/quadtree-definition">
                    ðŸ”—
                </a>
            </small></figcaption>
        </figure>

        <aside class="notes">
            <ul>
                <li>
                    Note: a <i>depth</i> corresponds to the number of bisections
                </li>
                <li>A.k.a. morton-ordering</li>
                <li>Avoiding massive pointer overhead mentioned earlier</li>
            </ul>
        </aside>
    </section>
    <section>
        <h1>&nbsp</h1>

        <ul>
            <li>Extension to global</li>
            <li>TODO</li>
        </ul>

        <figure>
            <img src="img/z-order-four-levels.svg" alt="z-order-four-levels"/>
            <h6>Z-order curve for depth 3</h6>
            <figcaption><small>
                By <a href="//commons.wikimedia.org/wiki/User:David_Eppstein" class="mw-redirect" title="User:David Eppstein">David Eppstein</a>, based on an image by <a href="//commons.wikimedia.org/wiki/User:Hesperian" title="User:Hesperian">Hesperian</a>. Own work</span>, <a href="http://creativecommons.org/licenses/by-sa/3.0/" title="Creative Commons Attribution-Share Alike 3.0">CC BY-SA 3.0</a>, <a href="https://commons.wikimedia.org/w/index.php?curid=3879675">ðŸ”—</a>
            </small></figcaption>
        </figure>

        <aside class="notes">
            <ul>
                <li>Important: these are <i>numbers</i>, not encodings</li>
                <li>Distinct from using padding for Z-order curve: 0 != 00</li>
                <li>Can perform queries with mathematical operators</li>
                <li>Just an infinitely long array, logically</li>
            </ul>
        </aside>
    </section>
</section>

<!-- 15 - Properties of our linearization -->
<section>
    <h1>Mathematical properties</h1>

    <ul>
        <li>Spacing guarantee in <i>O</i>(1) comparisons per depth</li>
        <li>Chunk on depth boundaries: can query LoDs with â‰¥ &amp; &lt;</li>
        <li>Hop down the array in constant time</li>
        <li>Never concerned with more than one point (concurrency!)</li>
        <li>Cache coherence</li>
    </ul>

    <figure>
        <img src="img/quadtree-layers.png" alt="quadtree-pyramid"/>
        <h6>Quadtree layering</h6>
        <figcaption><small>
            From <i>Towards Building Deep Networks with Bayesian Factor Graphs</i> by Buonanno &amp; Palmieri <a href="https://www.researchgate.net/figure/272422695_fig2_Figure-3-a-The-quadtree-architecture-b-Reduced-Normal-Factor-Graph-representation">ðŸ”—</a>
        </small></figcaption>
    </figure>
</section>

<!-- 16 - Entwine's chunking methodology -->
<section>
    <h1>Chunk splitting</h1>
    <ul>
        <li>Trivial to bound chunks spatially (parallelizable!)</li>
        <li>Sparse-chunking optimization</li>
        <li>^order of magnitude of key reduction)</li>
    </ul>
</section>


<!-- Results -->
<section data-markdown>
    # Post-implementation discussion stuff (TODO)
    ## What does entwine enable?

    - Quick overview of Greyhound
    - Then speck.ly/potree interface
    - CLI invocation samples, show "entwine build ..."
    - Show speed results - coordinator with AHN set
</section>

<!-- Final slide -->
<section data-markdown>
    ![logo](img/logo/color/entwine_logo_2-color.png)
    ## Links

    - Entwine - entwine.io
    - Plasio - speck.ly
</section>


<!--
<section data-markdown>
    ## The Netherlands
    - â‰ˆ 41,000 files
    - â‰ˆ 640 billion points
    - â‰ˆ 1.5 TB on disk
    - \> 7.5 TB uncompressed

    Note:
        Notes here.
</section>
-->



			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
        <script src="js/jquery-3.1.0.slim.min.js"></script>
		<script src="js/reveal.js"></script>
		<script src="js/init.js"></script>

		<link rel="stylesheet" href="css/post.css">

        <div id="hidden" style="display:none;">
            <div id="footer">
                <div id="footer-center">
                    <img
                        class="footer-logo"
                        src="img/logo/icons_favicons/entwine_icon_color.png">
                    </img>
                </div>
            </div>
        </div>

        <script src="js/footer.js"></script>
	</body>
</html>
