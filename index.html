<!doctype html>
<html>
	<head>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

		<title>Entwine slides</title>

		<link rel="stylesheet" href="css/reveal.css">
		<link rel="stylesheet" href="css/theme/entwine.css">
		<link rel="stylesheet" href="lib/css/zenburn.css">

		<script src="js/make-printable.js"></script>
	</head>
	<body>
		<div class="reveal">
			<div class="slides">


<!-- 01 - Title slide -->
<section>
    <img src="img/logo/color/entwine_logo_2-color.png" alt="logo"/>
    <h1>500+ Billion Points</h1>
    <h2>Organizing Point Clouds as Infrastructure</h2>
    <h3>Connor Manning</h3>

    <aside class="notes">
        <ul>
            <li>Focus is on the organization aspect: indexing</li>
        </ul>
    </aside>
</section>

<!-- 02 - Problem statement -->
<section>
    <h1>The problem</h1>
    <h2>Can we put Iowa's lidar in a web browser?</h2>
    <p><img src="img/iowa.png" alt="iowa"/></p>

    <aside class="notes">
        <ul>
            <li>Driving force behind implementation</li>
            <li>Why?
                <ul>
                    <li>Well, it would be cool</li>
                    <li>As seen soon, solving this has other benefits</li>
                </ul>
            </li>
        </ul>
    </aside>
</section>

<!-- 03 - Iowa info -->
<section>
    <h1>Iowa lidar collection</h1>

    <ul>
        <li>â‰ˆ 37,000 files</li>
        <li>â‰ˆ 170 billion points</li>
        <li>&gt; 4.5 TB uncompressed</li>
        <li>&gt; 400 GB compressed</li>
    </ul>

    <p><img src="img/iowa-s3-small.png" alt="iowa-s3"/></p>

    <aside class="notes">
        <ul>
            <li>Organized as full-resolution tiles</li>
        </ul>
    </aside>
</section>

<!-- 04 - want a service -->
<section>
    <h1>A point cloud service</h1>
    <ul>
        <li>Client-controlled access
            <ul>
                <li>Hierarchical</li>
                <li>Random-access</li>
                <li>Dynamic resolution</li>
                <li>Flexible</li>
            </ul>
        </li>
        <li>Fragmented dataset â†’ single logical unit</li>
    </ul>

    <aside class="notes">
        <ul>
            <li>Want an abstraction</li>
            <li>Doesn't necessarily need to be a dynamic service</li>
            <li>Static serving isn't ruled out</li>
            <li>Flexible - not <i>only</i> for visualization</li>
        </ul>
    </aside>
</section>

<!-- 05 - why can't we use the data in its current form? -->
<section>
    <h1>Adapting the data as-is?</h1>

    <ul>
        <li>Difficult to access</li>
        <li>Difficult to manage</li>
        <li>Visualization only in pieces</li>
    </ul>

    <figure>
        <img src="img/tiles.png" alt="tiles"/>
        <figcaption><small>Yes, Iowa is flat</small></figcaption>
    </figure>

    <aside class="notes">
        <ul>
            <li>A lot of data here - better not to touch it</li>
            <li>Difficult to access
                <ul>
                    <li>Clients can't drive the access</li>
                    <li>Have an AOI - need large downloads</li>
                    <li>No overview/preview</li>
                </ul>
            </li>
            <li>Difficult to manage - from a <i>logical</i> standpoint
                <ul>
                    <li>Can't treat data as a single unit</li>
                    <li>Need to sidecar metadata?</li>
                </ul>
            </li>
        </ul>
    </aside>
</section>

<!-- 06 - need to reorganize the data -->
<section>
    <h1>Need for reorganization</h1>

    <ul>
        <li>Cannot meet these needs with a <i>meta</i>-index</li>
        <li>Would require too much dynamic work</li>
        <li>Up-front cost is ok to trivialize later work</li>
    </ul>

    <aside class="notes">
        <ul>
            <li>Why no meta-index?
                <ul>
                    <li>Want to treat set as a logical unit</li>
                    <li>Need hierarchical access</li>
                    <li>Low-res overview has minimum of touching each file</li>
                </ul>
            </li>
            <li>Want to make queries trivial
                <ul>
                    <li>Otherwise ms response time impossible</li>
                    <li>Current organization is non-trivial</li>
                </ul>
            </li>
        </ul>
    </aside>
</section>

<!-- 07 - constraints -->
<section>
    <h1>Constraints</h1>

    <ul>
        <li>Memory</li>
        <li class="fragment">Losslessness</li>
        <li class="fragment">Modifiability</li>
        <li class="fragment">Visualization</li>
    </ul>

    <img src="img/free.png" alt="free"/>

    <aside class="notes">
        <ul>
            <li>Memory - can't fit entire uncompressed set in memory</li>
            <li>Lossless - want to cold-store original data</li>
            <li>Modifiability - can add more data after-the-fact</li>
            <li>Visualization
                <ul>
                    <li>millisecond response times</li>
                    <li>LoD structure - targeting dynamic clients</li>
                    <li>Client-controlled - plasio/potree/etc.</li>
                    <li>Static serve preferred - if server required its
                        query implementation should be trivial
                    </li>
                </ul>
            </li>
        </ul>
    </aside>
</section>

<!-- 08 - Assumptions -->
<section>
    <h1>Assumptions</h1>

    <ul>
        <li>Availability of scalable cloud computing</li>
        <li>A parallelizable problem</li>
        <li>Distributed filesystem</li>
    </ul>

    <figure>
        <img src="img/geyser-2.png" alt="geyser"/>
        <h6>Lone Star Geyser</h6>
        <figcaption><small>
            Geysers are kind of like clouds, but cooler.
            Data source: <a href="http://www.erdc.usace.army.mil/Locations/CRREL/Research.aspx">RS/GIS CRREL USACE</a>
        </small></figcaption>
    </figure>

    <aside class="notes">
        <ul>
            <li>Assume we can reasonably rent computing power on-demand</li>
            <li>Parallelizable from <i>practical</i> standpoint
                <ul>
                    <li>Entire dataset not random across all files</li>
                </ul>
            </li>
            <li>Filesystem scales with computing power</li>
        </ul>
    </aside>
</section>

<!-- 09 - Goal: a massive octree -->
<section>
    <h1>Goal: a massive octree</h1>
    <section transition="none">
        <h1>&nbsp;</h1>
        <ul>
            <li>Increase depth â†’ increase resolution</li>
        </ul>

        <figure>
            <img src="img/layers.png" alt="nepal-layers"/>
            <h6>Quadtree depth layering</h6>

            <figcaption><small>
                Data source: Vanuatu village, Nepal.
                <a href="http://www.globaldirt.org">Global DIRT</a>
            </small></figcaption>
        </figure>

        <aside class="notes">
            <ul>
                <li>A natural mechanism for visualization</li>
            </ul>
        </aside>
    </section>
    <section transition="none">
        <h1>&nbsp;</h1>
        <ul>
            <li>Spatially distinct â†’ trivially parallelizable</li>
        </ul>

        <figure>
            <img src="img/quadtree.svg" alt="quadtree-splitting"/>
            <h6>Quadtree splitting</h6>
            <figcaption><small>
                By <a href="//commons.wikimedia.org/wiki/User:David_Eppstein" class="mw-redirect" title="User:David Eppstein">David Eppstein</a>, Public Domain, <a href="https://commons.wikimedia.org/w/index.php?curid=2489019">ðŸ”—</a>
            </small></figcaption>
        </figure>

        <aside class="notes">
            <ul>
                <li>Trivial/natural method of parallelization</li>
            </ul>
        </aside>
    </section>
    <section>
        <h1>&nbsp;</h1>

        <ul>
            <li>Stable &amp; flexible</li>
            <li>Insertion order doesn't matter</li>
            <li>No concept of "balance"</li>
        </ul>

        <figure>
            <img src="img/kd-tree.svg" alt="kd-tree"/>
            <h6>By contrast: a KD-tree - where order matters</h6>
            <figcaption><small>
                By <a href="https://en.wikipedia.org/wiki/User:KiwiSunset" title="en:User:KiwiSunset">KiwiSunset</a> at the <a href="https://en.wikipedia.org/wiki/" title="w:">English language Wikipedia</a>, <a href="http://creativecommons.org/licenses/by-sa/3.0/" title="Creative Commons Attribution-Share Alike 3.0">CC BY-SA 3.0</a>, <a href="https://commons.wikimedia.org/w/index.php?curid=16242249">ðŸ”—</a>
            </small></figcaption>
        </figure>
        <aside class="notes">
            <ul>
                <li>Stable: no matter the impl details, output is the same</li>
                <li>Important for adding new data to index as it's scanned</li>
                <li>Avoids needing heuristics before indexing</li>
            </ul>
        </aside>
    </section>
</section>

<!-- 10 - Intro to octree -->
<section>
    <h1>Octrees</h1>

    <ul>
        <li>The basic implementation is pointer-based</li>
        <li>&gt; 10 TB just for the (64-bit) pointers for Iowa</li>
    </ul>

    <figure>
        <img src="img/octree.png" alt="octree-splitting"/>
        <h6>A classical octree</h6>
        <figcaption><small>
            By <a href="//commons.wikimedia.org/wiki/User:WhiteTimberwolf" title="User:WhiteTimberwolf">WhiteTimberwolf</a>  - <span lang="en">Own work</span>, <a href="http://creativecommons.org/licenses/by-sa/3.0/" title="Creative Commons Attribution-Share Alike 3.0">CC BY-SA 3.0</a>, <a href="https://commons.wikimedia.org/w/index.php?curid=9851485">ðŸ”—</a>
        </small></figcaption>
    </figure>

    <aside class="notes">
        <ul>
            <li>Key point: magnitude of data amplifies algorithmic waste</li>
            <li>Not to mention the lack of caching coherence</li>
            <li>Pointers take up more space then the point data!</li>
            <li>Each node holds a point, or <i>n</i> points</li>
        </ul>
    </aside>
</section>

<!-- 12 - Point spacing -->
<section>
    <h1>Point spacing</h1>

    <ul>
        <li>Important for visualization</li>
        <li>Requires per-point resolution
            <ul>
                <li>(as opposed to per-bucket)</li>
            </ul>
        </li>
    </ul>

    <figure>
        <span class="line">
            <img src="img/side-by-side-no-swap.png" alt="one" class="side-by-side"/>
            <img src="img/side-by-side-swapped.png" alt="two" class="side-by-side"/>
        </span>
            <h6>Lack of spacing guarantee - effect on visualization</h6>
        <figcaption><small>
        </small></figcaption>
    </figure>

    <aside class="notes">
        <ul>
            <li>With bucket-resolution, finding grid position is expensive</li>
            <li>Can't just accept first possible point</li>
            <li>...otherwise we'd be dependent on insertion order</li>
        </ul>
    </aside>
</section>

<!-- 11 - Bucketing overview -->
<section>
    <h1>Buckets of points?</h1>
    <ul>
        <li>A common approach</li>
        <li>Minimum addressable node consists of <i>n</i> points</li>
        <li>Calculating a grid position:
            <ul>
                <li><i>bucketWidth * (p - minBucketBound) / bucketSteps</i></li>
            </ul>
        </li>
    </ul>

    <figure>
        <span class="line">
            <img src="img/potree-root.png" class="line-4"/>
            <img src="img/potree-child.png" class="line-4"/>
            <img src="img/potree-root-and-child.png" class="line-4"/>
            <img src="img/potree-all-depths.png" class="line-4"/>
        </span>
        <h6>Point bucketing</h6>
        <figcaption><small>
            Source: Potree documentation <a href="https://github.com/potree/potree/blob/master/docs/file_format.md">ðŸ”—</a>
        </small></figcaption>
    </figure>

    <aside class="notes">
        <ul>
            <li>Lots of floating point math</li>
            <li>To ensure spacing: then need to calculate center</li>
            <li>...or check 26 neighbors</li>
            <li>Problem: speed scalability to massive datasets</li>
        </ul>
    </aside>
</section>

<!-- 13 - Bucketing computational complexity -->
<section>
    <h1>A matter of scale</h1>
    <ul>
        <li>Some numbers:
            <ul>
                <li><i>Bucket size</i> = 262,144</li>
                <li><i>Average depth</i> = 10</li>
            </ul>
        </li>
        <li>Expected comparisons: &gt; <i>10<sup>12</sup></i></li>
    </ul>

    <aside class="notes">
        <ul>
            <li>Per-comparison operations adds up</li>
            <li>This is just determining where to place data</li>
            <li>Not considering allocation etc.</li>
        </ul>
    </aside>
</section>

<!-- 14 - Entwine's linearization -->
<section>
    <h1>Linearizing the tree</h1>
    <section>
        <h1>&nbsp</h1>

        <ul>
            <li>For a single depth: Z-order curve</li>
            <li>Entirely positionally based - zero theoretical waste</li>
        </ul>

        <figure>
            <img src="img/morton-ordering.png" alt="morton-ordering"/>
            <h6>Z-order curve for depth 3</h6>
            <figcaption><small>
                By user <a href="http://www.slideserve.com/jace">Jace</a>,
                <a href="http://www.slideserve.com/jace/quadtree-definition">
                    ðŸ”—
                </a>
            </small></figcaption>
        </figure>

        <aside class="notes">
            <ul>
                <li>A.k.a. morton-ordering</li>
                <li>Assign numbers to each direction</li>
                <li>A <i>depth</i> corresponds to the number of bisections</li>
                <li>Avoiding massive pointer overhead mentioned earlier</li>
            </ul>
        </aside>
    </section>
    <section>
        <h1>&nbsp</h1>

        <ul>
            <li>Typically, multiple depths â†’ string-encoding
                <br>
                &nbsp; &nbsp; &nbsp; &nbsp; âˆ´ 0 â‰  00
            </li>
            <li>However, it's possible to globally linearize</li>
            <li>Doing this has some interesting properties</li>
        </ul>

        <figure>
            <img src="img/z-order-four-levels.svg" alt="z-order-four-levels"/>
            <h6>Z-order curve for depth 3</h6>
            <figcaption><small>
                By <a href="//commons.wikimedia.org/wiki/User:David_Eppstein" class="mw-redirect" title="User:David Eppstein">David Eppstein</a>, based on an image by <a href="//commons.wikimedia.org/wiki/User:Hesperian" title="User:Hesperian">Hesperian</a>. Own work</span>, <a href="http://creativecommons.org/licenses/by-sa/3.0/" title="Creative Commons Attribution-Share Alike 3.0">CC BY-SA 3.0</a>, <a href="https://commons.wikimedia.org/w/index.php?curid=3879675">ðŸ”—</a>
            </small></figcaption>
        </figure>
    </section>
    <section>
        <h1>&nbsp;</h1>

        <h2>Entwine's method</h2>

        <h3>TODO - diagram here</h3>

        <aside class="notes">
            <ul>
                <li>Important: these are <i>numbers</i>, not encodings</li>
                <li>Distinct from using padding for Z-order curve: 0 != 00</li>
                <li>Can perform queries with mathematical operators</li>
                <li>Logically: an infinitely long array</li>
            </ul>
        </aside>
    </section>
</section>

<!-- 15 - Properties of our linearization -->
<section>
    <h1>Properties</h1>

    <ul>
        <li>Spacing guarantee in <i>1</i> comparison per depth</li>
        <li>Can query tree depths with inequalities</li>
        <li>Concurrency-friendly</li>
        <li>Traversing the tree is very efficient</li>
    </ul>

    <figure>
        <img src="img/quadtree-layers.png" alt="quadtree-pyramid"/>
        <h6>Quadtree layering</h6>
        <figcaption><small>
            From <i>Towards Building Deep Networks with Bayesian Factor Graphs</i> by Buonanno &amp; Palmieri <a href="https://www.researchgate.net/figure/272422695_fig2_Figure-3-a-The-quadtree-architecture-b-Reduced-Normal-Factor-Graph-representation">ðŸ”—</a>
        </small></figcaption>
    </figure>

    <aside class="notes">
        <ul>
            <li>Concurrency-friendly:
                no neighbor checks - one position at a time
            </li>
            <li>Efficient: quick to climb depths.
                Also compact - no mappings required
            </li>
            <li>Don't need spatial query to select data</li>
            <li>Database-friendly - range-queryable</li>
        </ul>
    </aside>
</section>

<!-- 16 - Splitting methods -->
<section>
    <h1>Chunk splitting</h1>
    <section>
        <h2>Discrete steps?</h2>
        <ul>
            <li>Split bucketed node when <i>numPoints > bucketSize</i></li>
            <li>Will happen to high-traffic nodes frequently</li>
            <li>Concurrent throughput is reduced</li>
        </ul>

        <aside class="notes">
            <ul>
                <li>
                    High-level nodes will frequently split &amp; block everyone
                </li>
            </ul>
        </aside>
    </section>
    <section>
        <h1>&nbsp;</h1>
        <h2>Better: a priori</h2>
        <ul>
            <li>Trivial to bound chunks spatially - parallelizable!</li>
            <li>Sparse-chunking optimization
                <ul>
                    <li>Density multiplier decreases after
                        <i>log<sub>4</sub>(numPoints)</i>
                    <li>...so stop splitting spatially near that depth</li>
                    <span class="fragment">
                    <li>Order of magnitude of key reduction</li>
                    <li>
                        â†’ Order of magnitude of IO reduction
                    </li>
                    </span>
                </ul>
            </li>
        </ul>

        <aside class="notes">
            <ul>
                <li>How? Start on depth boundary and use binary sizing</li>
                <li>Parallelizable because files tend not to overlap</li>
                <li>Mapping acceptable for sparse chunks</li>
                <li>...because they're very geospatially specialized</li>
                <li>Theoretical points-per-chunk grows indefinitely</li>
                <li>Practial points-per-chunk shrinks</li>
            </ul>
        </aside>
    </section>
</section>

<!-- 17 - More tricks -->
<section>
    <h1>More tricks</h1>

    <ul>
        <li>Aggressive <span class="light">over-</span>optimization</li>
        <li>Heuristic tuning - over lots of data</li>
        <li>Custom big-integer library: <a href="https://github.com/connormanning/little-big-int">little-big-int</a></li>
        <li>Custom memory pool: <a href="https://github.com/connormanning/splice-pool">splice-pool</a></li>
    </ul>

    <aside class="notes">
        <ul>
            <li>Big-int: stack-allocator, good for small case</li>
            <li>Pool: reduce allocations &amp; concurrency blocks</li>
        </ul>
    </aside>
</section>

<!-- Results -->
<section>
    <h1>Results</h1>

    <section>
        <h1>&nbsp;</h1>
        <figure>
            <img src="img/first-worker-done-cropped.png"
                 alt="first-worker-done"/>
            <h6>Netherlands indexing pace</h6>
        </figure>
    </section>
    <section>
        <ul>
            <li>28 instances
                <ul>
                    <li>One instance: 30 cores, 60GB</li>
                    <li>Per-instance pace: â‰ˆ 2.65B points/hour</li>
                </ul>
            </li>
            <li>Total cost: â‰ˆ $400</li>
            <li>Total time: &lt; 9.5 hours</li>
        </ul>
    </section>
</section>

<section>
    <h1>What do we get?</h1>
    <video controls="controls"
           alt="zoom"
           data-src="img/zoom.mov">
    </video>
    <h6>Rijksmuseum</h6>
</section>

<section>
    <h1>How can we use it?</h1>
    <section>
        <h1>&nbsp;</h1>
        <h2>Greyhound</h2>
        <ul>
            <li>A simple RESTful HTTP server</li>
            <li><code>http://data.greyhound.io/resource/iowa/info</code></li>
            <li><code>http://data.greyhound.io/resource/iowa/read?</code>
                <ul>
                    <li><code>
                        bounds=[-10758084,4793192,-361921,-10034124,5517152,362039]&amp;
                    </code></li>
                    <li><code>
                        depth=10&amp;
                    </code></li>
                    <li><code>
                        compress=true&amp;
                    </code></li>
                    <li><code>
                        schema=[{name:"X",type:"floating",size:"8"}, ...]
                    </code></li>
                </ul>
            </li>
        </ul>
    </section>
    <section>
        <h1>&nbsp;</h1>
        <h2>Other projects</h2>
        <ul>
            <li>Speck.ly <a href="http://speck.ly">ðŸ”—</a></li>
            <li>Potree fork <a href="http://potree.entwine.io">ðŸ”—</a></li>
            <li>PDAL reader (in progress) <a href="http://pdal.io">ðŸ”—</a></li>
        </ul>

        <aside class="notes">
            <ul>
                <li>speck.ly: raster-tile splatting</li>
                <li>Potree: works on mobile</li>
            </ul>
        </aside>
    </section>
</section>

<section>
    <h1>Using it</h1>

    <ul>
        <li><code>entwine build</code>
            <ul>
                <li class="fragment"><code>-i ~/data/iowa</code></li>
                <li class="fragment"><code>-o ~/entwine/iowa</code></li>
                <li class="fragment"><code>-r EPSG:3857</code></li>
                <li class="fragment"><code>-t 12</code></li>
            </ul>
        </li>
    </ul>

    <aside class="notes">
        <ul>
            <li>Docker mention</li>
        </ul>
    </aside>
</section>

<!-- Final slide -->
<section>
    <img alt="logo" src="img/logo/color/entwine_logo_2-color.png"/>
    <h2>Links</h2>

    <ul>
        <li>Entwine - <a href="http://entwine.io">entwine.io</a></li>
        <li>Plasio - <a href="http://speck.ly">speck.ly</a></li>
        <li>PDAL - <a href="http://pdal.io">pdal.io</a></li>
        <li>Greyhound - <a href="http://greyhound.io">greyhound.io</a></li>
    </ul>
</section>


<!--
<section data-markdown>
    ## The Netherlands
    - â‰ˆ 41,000 files
    - â‰ˆ 640 billion points
    - â‰ˆ 1.5 TB on disk
    - \> 7.5 TB uncompressed

    Note:
        Notes here.
</section>
-->



			</div>
		</div>

		<script src="lib/js/head.min.js"></script>
        <script src="js/jquery-3.1.0.slim.min.js"></script>
		<script src="js/reveal.js"></script>
		<script src="js/init.js"></script>

		<link rel="stylesheet" href="css/post.css">

        <div id="hidden" style="display:none;">
            <div id="footer">
                <div id="footer-center">
                    <img
                        class="footer-logo"
                        src="img/logo/icons_favicons/entwine_icon_color.png">
                    </img>
                </div>
            </div>
        </div>

        <script src="js/footer.js"></script>
	</body>
</html>
